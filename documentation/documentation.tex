\documentclass[a4paper]{article}

\usepackage[italian]{babel}
\usepackage{float}
\usepackage{makecell}
\usepackage{csquotes}
\usepackage[backend=biber]{biblatex}
\addbibresource{./references.bib}

\usepackage{hyperref}
\hypersetup{
  colorlinks=false,
}

% Code blocks
\usepackage{listings}
\usepackage{xcolor}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.95}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,
	breaklines=true,
	captionpos=b,
	keepspaces=true,
	numbers=left,
	numbersep=5pt,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2
}

\lstset{style=mystyle}

\begin{document}

\input{title.tex}

\tableofcontents
\pagebreak

\section{Introduzione}
Questo progetto consiste nell'implementazione di un sistema che permetta di aggiornare
il firmware dell'ESP32 da remoto (Over The Air) tramite Wi-Fi. L'obiettivo principale è
quello di attivare le funzionalità di sicurezza del microcontrollore in modo da proteggere
il dispositivo da accessi non autorizzati. Le funzionalità di sicurezza includono:
\begin{itemize}
  \item \textbf{Secure OTA}: Garantisce che il nuovo firmware sia autentico e non
    compromesso
  \item \textbf{Secure Boot}: Impedisce l'esecuzione di firmware non autorizzato
  \item \textbf{Flash Encryption}: Protegge i dati memorizzati nella memoria flash
    del dispositivo
\end{itemize}


\section{Cenni teorici}

\subsection{Aggiornamenti OTA (Over The Air)}
Gli aggiornamenti OTA permettono di aggiornare il firmware del dispositivo durante la
sua normale esecuzione, senza la necessità di collegarlo fisicamente a un computer. Le
modalità di aggiornamento si distinguono in base alla vulnerabilità del sistema:
\begin{itemize}
  \item \textbf{Modalità sicura}: L'aggiornamento di alcune partizioni è resiliente,
    cioè garantisce l'operabilità del dispositivo anche in caso di perdita di alimentazione
    o di errore durante l'aggiornamento. Solo il seguente tipo di partizione supporta
    la modalità sicura:
    \begin{itemize}
      \item \textbf{Application}: OTA configura la partition table in modo da avere
        due partizioni per l'aggiornamento (\texttt{ota\_0} e \texttt{ota\_1}) e una
        partizione per lo stato di boot (\texttt{ota\_data}). Durante l'aggiornamento il
        nuovo firmware viene scritto nella partizione OTA attualmente non selezionata
        per il boot. Una volta completato l'aggiornamento, la partizione \texttt{ota\_data}
        viene aggiornata per indicare che la partizione OTA appena scritta deve essere
        utilizzata al boot successivo. Se la partizione \texttt{ota\_data} non contiene
        alcun dato il dispositivo esegue il boot dalla partizione \texttt{factory}.

        La partition table con due partizioni OTA è la seguente:
        \begin{lstlisting}
# ESP-IDF Partition Table
# Name,   Type, SubType, Offset,  Size, Flags
nvs,      data, nvs,     0x9000,  0x4000,
otadata,  data, ota,     0xd000,  0x2000,
phy_init, data, phy,     0xf000,  0x1000,
factory,  app,  factory, 0x10000,  1M,
ota_0,    app,  ota_0,   0x110000, 1M,
ota_1,    app,  ota_1,   0x210000, 1M,
        \end{lstlisting}
    \end{itemize}
  \item \textbf{Modalità non sicura}: L'aggiornamento di alcune partizioni è vulnerabile,
    cioè in caso di perdita di alimentazione o di errore durante l'aggiornamento il
    dispositivo potrebbe non essere più operabile. Una partizione temporanea riceve
    i dati della nuova immagine e, una volta completato il trasferimento, l'immagine viene
    copiata nella partizione di destinazione. Se l'operazione di copia viene interrotta
    potrebbero verificarsi problemi di boot. Le partizioni che supportano la modalità non
    sicura sono:
    \begin{itemize}
      \item \textbf{Bootloader}
      \item \textbf{Partition Table}
      \item \textbf{Partizioni data} (ad esempio NVS, FAT, ecc...)
    \end{itemize}
\end{itemize}

\subsubsection{Partizione OTA Data}
Al primo avvio del dispositivo la partizione \texttt{ota\_data} deve essere vuota (tutti i
byte a 0xFF) in modo da far eseguire il boot dal'applicazione nella partizione
\texttt{factory}. Se l'applicazione in \texttt{factory} non è presente viene eseguito il boot
della prima partizione OTA disponibile (di solito \texttt{ota\_0}).

Dopo il primo aggiornamento OTA, la partizione \texttt{ota\_data} viene aggiornata per
indicare quale partizione OTA deve essere utilizzata al successivo boot. La dimensione
di \texttt{ota\_data} è di due settori (0x2000 bytes = 8192 bytes) in modo da evitare
errori mentre si scrive la partizione. I due settori sono cancellati indipendentemente
e scritti con gli stessi dati. In questo modo se i dati dei due settori non coincidono
viene usato un counter per determinare quale settore è stato scritto più recentemente.

\subsubsection{App rollback}
L'obiettivo dell'app rollback è quello di tenere il funzionante il dispositivo dopo un
aggiornamento e permette di tornare alla versione precedente del firmware se la nuova
versione non funziona correttamente (solo le partizioni OTA possono effettuare il rollback).
Dopo un aggiornamento OTA con rollback attivo si hanno le seguenti possibilità:
\begin{itemize}
  \item Se l'app funziona bene \texttt{esp\_ota\_mark\_app\_valid\_cancel\_rollback()}
    imposta lo stato dell'applicazione a \texttt{ESP\_OTA\_IMG\_VALID}.

  \item Se l'app non funziona correttamente il dispositivo esegue il rollback alla versione
    precedente e \texttt{esp\_ota\_mark\_app\_invalid\_rollback()} imposta lo stato
    dell'applicazione a \texttt{ESP\_OTA\_IMG\_INVALID}.

  \item Se l'impostazione \texttt{CONFIG\_BOOTLOADER\_APP\_ROLLBACK\_ENABLE} è abilitata
    e viene effettuato un reset, allora viene effettuato un rollback senza chiamare
    nessuna funzione nell'applicazione. Questa opzione permette di intercettare la
    prima esecuzione di una nuova applicazione per confermare che funzioni correttamente.
\end{itemize}

\vspace{1em}
\noindent
Gli stati che controllano il processo di selezione dell'applicazione sono:
\begin{table}[H]
  \centering
  \begin{tabular}{|l|l|}
    \hline
    \textbf{Stato} & \textbf{Restrizioni sulla nuova app} \\
    \hline
    \texttt{ESP\_OTA\_IMG\_VALID} & Nessuna restrizione. Verrà selezionata \\
    \hline
    \texttt{ESP\_OTA\_IMG\_UNDEFINED} & Nessuna restrizione. Verrà selezionata \\
    \hline
    \texttt{ESP\_OTA\_IMG\_INVALID} & Non verrà selezionata \\
    \hline
    \texttt{ESP\_OTA\_IMG\_ABORTED} & Non verrà selezionata \\
    \hline
    \texttt{ESP\_OTA\_IMG\_NEW} & \makecell[l]{Se l'opzione \\
    \texttt{CONFIG\_BOOTLOADER\_APP\_ROLLBACK\_ENABLE} \\
    è abilitata, l'app verrà selezionata solo una \\
    volta. Nel bootloader lo stato viene subito \\
    impostato a \texttt{ESP\_OTA\_IMG\_PENDING\_VERIFY}.} \\
    \hline
      \texttt{ESP\_OTA\_IMG\_PENDING\_VERIFY} & \makecell[l]{Se l'opzione \\
    \texttt{CONFIG\_BOOTLOADER\_APP\_ROLLBACK\_ENABLE} \\
    è abilitata, l'app non verrà selezionata. \\
    Nel bootloader lo stato viene \\
    impostato a \\
    \texttt{ESP\_OTA\_IMG\_ABORTED}.} \\
    \hline
  \end{tabular}
  \caption{Stati dell'applicazione OTA}
\end{table}
\noindent
L'impostazione di questi stati avviene nei seguenti casi:
\begin{itemize}
  \item \texttt{ESP\_OTA\_IMG\_VALID}: impostato dalla funzione \\
    \texttt{esp\_ota\_mark\_app\_valid\_cancel\_rollback()}.

  \item \texttt{ESP\_OTA\_IMG\_UNDEFINED}: impostato dalla funzione \\
    \texttt{esp\_ota\_set\_boot\_partition()} se l'impostazione \\
    \texttt{CONFIG\_BOOTLOADER\_APP\_ROLLBACK\_ENABLE} è disabilitata.

  \item \texttt{ESP\_OTA\_IMG\_NEW}: impostato dalla funzione \\
    \texttt{esp\_ota\_set\_boot\_partition()} se l'impostazione \\
    \texttt{CONFIG\_BOOTLOADER\_APP\_ROLLBACK\_ENABLE} è abilitata.

  \item \texttt{ESP\_OTA\_IMG\_INVALID}: impostato dalla funzione \\
    \texttt{esp\_ota\_mark\_app\_invalid\_rollback()} o \\
    \texttt{esp\_ota\_mark\_app\_invalid\_rollback\_and\_reboot()}.

  \item \texttt{ESP\_OTA\_IMG\_ABORTED}: impostato se l'operabilità dell'applicazione non
    è stata confermata e avviene un reboot quando l'impostazione \\
    \texttt{CONFIG\_BOOTLOADER\_APP\_ROLLBACK\_ENABLE} è abilitata.

  \item \texttt{ESP\_OTA\_IMG\_PENDING\_VERIFY}: impostato nel bootloader se l'impostazione \\
    \texttt{CONFIG\_BOOTLOADER\_APP\_ROLLBACK\_ENABLE} è abilitata e l'applicazione
    selezionata è nello stato \texttt{ESP\_OTA\_IMG\_NEW}.
\end{itemize}

\subsection{eFuse}
Gli \texttt{eFuse} (electronic fuses) sono memorie non volatili che possono essere
programmate (burned) una sola volta. Gli \texttt{eFuse} sono campi da \textbf{un bit}
che può essere impostato a 1, ma non può essere riportatoo a 0 e servono per memorizzare
valori di sistema o dell'utente. I bit sono raggruppati in 4 blocchi da 256 bit e 
ogni blocco è suddiviso in 8 registri da 32 bit. Alcuni blocchi sono riservati per i
valori di sistema e altri sono liberi per l'uso dell'utente.
I blocchi degli \texttt{eFuse} sono divisi in:
\begin{itemize}
  \item \texttt{EFUSE\_BLK0}: è interamente riservato ai valori di sistema
  \item \texttt{EFUSE\_BLK1}: è utilizzato per le chiavi della Flash Encryption se
    attivata, altrimenti può essere usato dall'utente
  \item \texttt{EFUSE\_BLK2}: è utilizzato per la chiave del Secure Boot se attivo,
    altrimenti può essere usato dall'utente
  \item \texttt{EFUSE\_BLK3}: può essere riservato per memorizzare un indirizzo MAC
    personalizzato oppure può essere usato dall'utente. Alcuni bit sono già usati
    in ESP-IDF.
\end{itemize}
Non tutti i bit possono essere utilizzati.

\subsection{Secure Boot}
Il Secure Boot protegge il dispositivo dall'esecuzione di firmware non autorizzato
verificando che ogni software (second stage bootloader e ogni applicazione)
che viene eseguito sia firmato. Il first stage bootloader non deve essere firmato
in quanto è memorizzato in una memoria ROM (di sola lettura).
La firma è una coppia di chiavi (privata e pubblica) generata tramite l'algoritmo
RSA.
\begin{itemize}
  \item La chiave privata viene utilizzata per firmare il software prima
    che venga caricato nel dispositivo.
  \item La chiave pubblica viene memorizzata nel dispositivo e viene utilizzata
    per verificare la firma del software prima che venga eseguito.
\end{itemize}

\noindent
In breve, il processo
di Secure Boot funziona come segue:
\begin{enumerate}
  \item Il first stage bootloader carica il second stage bootloader e ne verifica la firma.
    Solo se la verifica va a buon fine il second stage bootloader viene eseguito.
  \item Il second stage bootloader carica l'applicazione e ne verifica la firma.
    Solo se la verifica va a buon fine l'applicazione viene eseguita.
\end{enumerate}

\subsubsection{Vantaggi}
I vantaggi del Secure Boot sono:
\begin{itemize}
  \item La chiave pubblica è memorizzata sul dispositivo, mentre quella privata è 
    tenuta in un posto sicuro e non viene mai usata dal dispositivo.

  \item Solo una chiave pubblica può essere generata e memorizzata nel chip
    durante la fase di produzione.

  \item Viene usato lo stesso formato di immagine del firmware e della firma sia
    per il second stage bootloader che per le applicazioni.

  \item Nessun dato segreto viene memorizzato nel dispositivo.
\end{itemize}

\subsubsection{Formato del signature block}
Il signature block è una struttura che contiene la firma del software.
Il blocco inizia su un confine allineato a 4 KB e ha un proprio settore di flash,
cioè 4096 byte. La firma viene calcolata su \textbf{tutti i byte} dell'immagine,
inclusi i byte di "secure padding" (vedi capitolo \ref{Secure padding}).
Ogni signature block contiene la firma dell'immagine a cui appartiene insieme alla
chiave pubblica RSA usata per la verifica della firma.
Il formato del signature block è il seguente:
\begin{table}[H]
  \centering
  \begin{tabular}{|l|l|l|}
    \hline
    \textbf{Offset} & \textbf{Dimensione (byte)} & \textbf{Descrizione} \\
    \hline
      0 & 1 & Byte magico (deve essere \texttt{0xE7})\\
    \hline
      1 & 1 & \makecell[l]{
        Byte della versione,\\
        per Secure Boot v2 è \texttt{0x02}
      } \\
    \hline
      2 & 2 &
      \makecell[l]{
        Byte di padding.\\
        Riservati e devono essere a 0
      } \\
    \hline
      4 & 32 & \makecell[l]{
        Hash SHA-256 del contenuto \\
        dell'immagine, senza considerare \\
        il signature block
      } \\
    \hline
      36 & 384 & \makecell[l]{
        Modulo RSA usato per la verifica \\
        della firma. \\
        (valore \texttt{"n"} nella specifica
        \href{https://www.rfc-editor.org/rfc/rfc8017.html}{RFC8017})
      } \\
    \hline
      420 & 4 & \makecell[l]{
        Esponente pubblico RSA usato \\
        per la verifica della firma. \\
        (valore \texttt{"e"} nella specifica
        \href{https://www.rfc-editor.org/rfc/rfc8017.html}{RFC8017})
      } \\
    \hline
      424 & 384 & \makecell[l]{
        Valore precalcolato di \texttt{"R"}, derivato da \\
        \texttt{"n"}, usato per l'algoritmo di \\
        moltiplicazione di Montgomery
      } \\
    \hline
      808 & 4 & \makecell[l]{
        Valore precalcolato di \texttt{"M'"}, derivato da \\
        \texttt{"n"}, usato per l'algoritmo di \\
        moltiplicazione di Montgomery
      } \\
    \hline
      812 & 384 & \makecell[l]{
        Firma RSA-PSS \\
        (sezione 8.1.1 della \href{https://www.rfc-editor.org/rfc/rfc8017.html}{RFC8017})
        del \\ contenuto dell'immagine, calcolata \\ usando i seguenti
        parametri PSS: \\ hash SHA-256, funzione MGF1, \\ lunghezza
        del salt 32 bytes, campo trailer \\ di default 0xBC.
      } \\
    \hline
      1196 & 4 & \makecell[l]{
        CRC32 (checksum) dei precedenti 1196 \\ bytes
      } \\
    \hline
      1200 & 16 & \makecell[l]{
        Byte di padding a 0 per arrivare a \\ lunghezza 1216 bytes
      } \\
    \hline
  \end{tabular}
  \caption{Formato del signature block}
\end{table}
\noindent
Lo spazio rimanente dopo il signature block (4096 - 1216 = 2880 bytes) è memoria
flash cancellata, cioè tutti i byte a 0xFF, che può essere usata per scrivere altri
signature block dopo il precedente.

\vspace{1em}
\label{Verifica del signature block}
\noindent
Un signature block è valido se soddisfa entrambe le condizioni:
\begin{itemize}
  \item Il byte magico è corretto (\texttt{0xE7})
  \item La checksum CRC32 è corretta
\end{itemize}
altrimenti viene considerato non valido.

\subsubsection{Secure padding} \label{Secure padding}
Il secure padding è un'area di memoria che viene aggiunta alla fine di ogni
immagine del firmware per allineare l'immagine al confine della dimensione di pagina
della flash MMU (Memory Management Unit con dimensione default di 64KB).
Questo viene fatto per assicurare che soltanto
contenuti verificati vengano mappati nella memoria indirizzabile del dispositivo.
La firma dell'immagine viene calcolata dopo aver aggiunto il secure padding e solo
dopo viene aggiunto alla fine il signature block (4KB).


\subsubsection{Verifica di un'immagine}
Un esempio di applicazione firmata è il seguente:
\begin{table}[H]
  \centering
  \begin{tabular}{|l|l|l|}
    \hline
    \textbf{Offset} & \textbf{Dimensione (KB)} & \textbf{Descrizione} \\
    \hline
    0 & 580 & \makecell[l]{
      Contenuto di esempio di un'applicazione \\ non firmata
    } \\
    \hline
    580 & 60 & \makecell[l]{
      Secure padding per allineare l'immagine \\ al prossimo confine di 64KB
    } \\
    \hline
    640 & 4 & Signature block \\
    \hline
  \end{tabular}
  \caption{Esempio di applicazione firmata}
\end{table}
\noindent
L'immagine dell'applicazione inizia sempre al prossimo confine di pagina della flash MMU,
di default 64KB, e quindi lo spazio rimanente dopo il signature block può essere
utilizzato per memorizzare altre partizioni di dati, ad esempio \texttt{nvs}.

\vspace{1em}
\label{Verifica di un'immagine}
\noindent
Un'immagine è verificata se la chiave pubblica memorizzata in qualsiasi signature block
è valida per quel dispositivo, e se la firma RSA-PSS nel signature block coincide con
la firma calcolata per i dati dell'immagine letti dalla flash.
La verifica dell'immagine non viene effettuata soltanto ad ogni boot, ma anche dopo
ogni aggiornamento OTA. Se la verifica della nuova immagine ottenuta tramite OTA
fallisce, il bootloader cercherà un'altra immagine valida da eseguire.
I passaggi per verificare un'immagine sono i seguenti:
\begin{enumerate}
  \item Confrontare l'hash SHA-256 della chiave pubblica memorizzata nel signature block
    del bootloader con quello memorizzato negli \texttt{eFuse} del dispositivo.
    Se non coincidono, l'immagine non è valida.

  \item Generare l'hash dell'immagine dell'applicazione e confrontarlo con l'hash
    memorizzato nel signature block dell'immagine. Se non coincidono, l'immagine
    non è valida.

  \item Usare la chiave pubblica per verificare la firma dell'immagine del bootloader
    usando RSA-PSS (sezione 8.1.2 della \href{https://www.rfc-editor.org/rfc/rfc8017.html}{RFC8017})
    per confrontarla con l'hash dell'immagine calcolato nel passo 2.
\end{enumerate}

\subsubsection{Processo di Secure Boot}
I passi eseguiti durante il processo di Secure Boot sono i seguenti:
\begin{enumerate}
  \item All'avvio, il codice salvato in ROM (first stage bootloader) controlla
    il bit di Secure Boot v2 negli \texttt{eFuse} del dispositivo. Se il bit è
    disabilitato, il dispositivo esegue il boot normalmente, altrimenti procede al
    passo successivo.

  \item Il codice in ROM verifica il signature block del bootloader
    (vedi \ref{Verifica del signature block}). Se fallisce
    il processo di boot viene interrotto. 

  \item Il codice in ROM verifica l'immagine del bootloader usando i dati dell'immagine,
    i signature block corrispondenti e gli \texttt{eFuse} (vedi \ref{Verifica di un'immagine}).
    Se la verifica fallisce il processo di boot viene interrotto.

  \item Il codice in ROM esegue il bootloader.

  \item Il bootloader verifica il signature block dell'immagine dell'applicazione.
    Se fallisce il processo di boot viene interrotto. \label{Verifica del signature block app}

  \item Il bootloader verifica l'immagine dell'applicazione usando i dati dell'immagine,
    i signature block corrispondenti e gli \texttt{eFuse}.
    Se la verifica fallisce il processo di boot viene interrotto, ma se viene trovata
    un'altra immagine, allora il bootloader proverà a verificare quell'immagine tornando
    ad eseguire i punti dal \ref{Verifica del signature block app} al
    \ref{Esecuzione dell'applicazione verificata}. Questo viene ripetuto finchè non viene
    trovata un'immagine valida o non ci sono più immagini da verificare.

  \item \label{Esecuzione dell'applicazione verificata}
    Il bootloader esegue l'immagine dell'applicazione verificata.
\end{enumerate}

\section{Implementazione}

\subsection{Aggiornamenti OTA}
\subsubsection{Configurazione del progetto}
Per abilitare gli aggiornamenti OTA è stato necessario configurare il progetto ESP-IDF
con le seguenti componenti:
\begin{itemize}
  \item \textbf{Partition table e memoria flash}: è stato creato il file\\
    \texttt{sdkconfig.defaults}
    che contiene la configurazione di default del progetto. All'interno è stato
    definito l'utilizzo della partition table con due partizioni OTA:
\begin{lstlisting}
CONFIG_PARTITION_TABLE_TWO_OTA=y
\end{lstlisting}
    e sono state impostate le dimensioni della memoria flash a 4MB:
\begin{lstlisting}
CONFIG_ESPTOOLPY_FLASHSIZE_4MB=y
\end{lstlisting}

  \item \textbf{Server HTTP}: per permettere il download del nuovo firmware è stato
    creato un server HTTP in \texttt{server/pytest\_simple\_ota.py} che rende
    disponibile il file binario del firmware aggiornato.

    Il server richiede, nella sua cartella, la presenza di un certificato SSL per
    permettere connessioni sicure attraverso HTTPS. Il certificato è stato generato
    eseguendo il seguente comando nella cartella \texttt{server/}:
\begin{lstlisting}
cd server
openssl req -x509 -newkey rsa:2048 -keyout ca_key.pem -out ca_cert.pem -days 365 -nodes
\end{lstlisting}
    \textbf{Nota}: durante la creazione del certificato nel campo \texttt{Common Name (CN)}
    deve essere inserito il nome host del server. Se il server viene eseguito in locale
    il campo deve essere impostato con l'indirizzo IP del server.

    Una volta generato il certificato bisogna flashare il file \texttt{ca\_cert.pem}
    sul dispositivo in modo che possa verificare l'autenticità del server.
    Per fare ciò bisogna copiare il file nella cartella \texttt{server\_certs/} del
    progetto:
\begin{lstlisting}
cp ca_cert.pem ../server_certs
\end{lstlisting}
    Inoltre è necessario modificare il file \texttt{main/CMakeLists.txt} per includere
    il certificato nel firmware:
\begin{lstlisting}
idf_build_get_property(project_dir PROJECT_DIR)
idf_component_register(SRCS "main.c" INCLUDE_DIRS "."
    EMBED_TXTFILES ${project_dir}/server_certs/ca_cert.pem)
\end{lstlisting}

    Una volta configurato il tutto, il server può essere avviato eseguendo il comando:
\begin{lstlisting}
python pytest_simple_ota.py <BIN_DIR> <PORT> [CERT_DIR]
\end{lstlisting}
    Dove:
    \begin{itemize}
      \item \texttt{<BIN\_DIR>} è la cartella che contiene il file binario del firmware.
      \item \texttt{<PORT>} è la  porta su cui eseguire il server HTTP.
      \item \texttt{[CERT\_DIR]} (opzionale) è cartella che contiene il certificato SSL
        del server. Se non viene specificata viene usata la cartella corrente.
    \end{itemize}
    Se tutto è andato a buon fine l'output del server sarà simile al seguente:
\begin{lstlisting}
$ python pytest_simple_ota.py build 8070
Starting HTTPS server at "https://:8070"
192.168.10.106 - - [01/Jan/2026 12:00:00] "GET /esp32_secure_ota.bin HTTP/1.1" 200 -
\end{lstlisting}

  \item \textbf{Supporto del versionamento}: per tenere traccia delle versioni del firmware
    è stato aggiunto il file \texttt{version.txt} nella cartella principale del progetto
    che contiene il numero di versione corrente. Questo numero viene inserito nel
    file binario del firmware durante la compilazione e può essere letto dall'applicazione
    per confrontare la versione corrente con quella disponibile sul server ed evitare
    aggiornamenti non necessari.

  \item \textbf{Accesso Wi-Fi}: per connettere il dispositivo alla rete Wi-Fi è stata
    implementata la logica di connessione nel file \texttt{main/wifi.c}.

  \item \textbf{Configurazione Wi-Fi e server HTTP}: per fornire le credenziali di
    accesso alla rete Wi-Fi e l'indirizzo del server HTTP è stata creata una sezione
    nel menu di configurazione del progetto (menuconfig), nel file
    \texttt{main/Kconfig.projbuild}. Per accedere al menuconfig bisogna eseguire
    il comando:
\begin{lstlisting}
idf.py menuconfig
\end{lstlisting}
    e navigare fino alla sezione \texttt{Over The Air Updates configuration} dove è
    possibile impostare:
    \begin{itemize}
      \item \textbf{Wifi configuration}
        \begin{itemize}
          \item \texttt{SSID}: nome della rete Wi-Fi
          \item \texttt{Password}: password della rete Wi-Fi
          \item \texttt{Maximum retries}: numero massimo di tentativi di riconnessione
          \item \texttt{WPA3 SAE mode selection}: modalità di autenticazione WPA3
          \item \texttt{Password identifier}: identificatore della password WPA3
          \item \texttt{WiFi Scan auth mode threshold}: modalità di
            autenticazione minima accettata durante la scansione delle reti
        \end{itemize}

      \item \textbf{Upgrade server}
        \begin{itemize}
          \item \texttt{Firmware upgrade URL}: URL del server HTTP che ospita il file
            binario del firmware. Deve essere nel formato:
\begin{lstlisting}
https://<host-ip-address>:<host-port>/<firmware-image-filename>
\end{lstlisting}
            dove:
            \begin{itemize}
              \item \texttt{<host-ip-address>}: hostname o indirizzo IP del server\\ HTTP.
              \item \texttt{<host-port>}: porta su cui è in esecuzione il server HTTP.
              \item \texttt{<firmware-image-filename>}: nome del file binario del\\ firmware.
                \textbf{Deve coincidere con il nome del file messo a disposizione dal server}.
            \end{itemize}

          \item \texttt{Skip server certificate CN field check}: se abilitato, il
            dispositivo non verificherà il campo \texttt{Common Name (CN)} del
            certificato SSL. Utile per testare il server in locale senza dover generare
            un certificato con l'indirizzo IP come CN.

          \item \texttt{Skip firmware version check}: se abilitato, il dispositivo non
            confronterà la versione del firmware corrente con quella disponibile sul
            server prima di effettuare l'aggiornamento OTA.

          \item \texttt{OTA recieve timeout}: tempo massimo (in millisecondi)
            per ricevere una risposta dal server HTTP durante l'aggiornamento OTA.
        \end{itemize}

    \end{itemize}
\end{itemize}

\subsubsection{Connessione Wi-Fi}
La connessione alla rete Wi-Fi viene gestita nel file \texttt{main/wifi.c} che
fornisce la funzione \texttt{connect\_wifi()}. Questa funzione gestisce la connessione
alla rete Wi-Fi utilizzando le credenziali fornite nel menuconfig e la riconnessione
in caso di disconnessione. La funzione esegue i seguenti passaggi:
\begin{enumerate}
  \item Inizializza il driver Wi-Fi
  \item Chiama un handler per gestire gli eventi di connessione e disconnessione 
    dalla rete Wi-Fi
  \item Chiama un handler per gestire l'acquisizione dell'indirizzo IP
  \item Imposta il device in modalità stazione Wi-Fi con la configurazione fornita
    dal menuconfig
  \item Avvia la connessione alla rete Wi-Fi
  \item Attende fino a quando il dispositivo non si connette alla rete o raggiunge
    il numero massimo di tentativi di riconnessione
  \item Restituisce lo stato della connessione (successo o fallimento)
\end{enumerate}

\subsubsection{Aggiornamento OTA}
L'aggiornamento OTA viene gestito nel file \texttt{main/ota.c} che fornisce le funzione
\texttt{download\_new\_firmware()} e \texttt{diagnose\_new\_firmware()}. La funzione
\texttt{download\_new\_firmware()} connette il dispositivo al server HTTP e scarica
il nuovo firmware, se disponibile, e lo imposta come nuova applicazione di boot.
I passi eseguiti sono i seguenti:
\begin{enumerate}
  \item Recupera le partizioni di boot e OTA correnti
  \item Si connette al server HTTP utilizzando l'URL fornito nel menuconfig
  \item Recupera la partizione OTA non attualmente in uso per il boot
  \item Legge il file binario del firmware dal server HTTP
  \item Confronta la versione del firmware corrente con quella scaricata
    \begin{itemize}
      \item Se l'aggiornamento non è necessario viene eseguito un loop infinito
        che attende un reset del dispositivo per ritentare l'aggiornamento
    \end{itemize}
  \item Inizializza l'aggiornamento OTA
  \item Scrive i dati del firmware scaricato nella partizione OTA non in uso
  \item Controlla che tutti i dati siano stati scritti correttamente
  \item Disattiva l'aggiornamento OTA
  \item Imposta la partizione OTA appena scritta come partizione di boot
  \item Riavvia il dispositivo per eseguire il nuovo firmware
\end{enumerate}

\noindent
La funzione \texttt{diagnose\_new\_firmware()} permette di verificare se il nuovo
firmware funziona correttamente e, in caso negativo, effettua il rollback alla versione
precedente. I passi eseguiti sono i seguenti:
\begin{enumerate}
  \item Controlla se l'applicazione corrente è al primo avvio dopo un aggiornamento OTA
  \item Esegue la funzione di diagnosi del firmware (in questo caso un semplice delay di
    5 secondi che simula un controllo)
    \begin{itemize}
      \item Se la diagnosi ha esito positivo, conferma che il nuovo firmware è valido
        e cancella il rollback
      \item Se la diagnosi ha esito negativo, marca il firmware come non valido
        ed esegue il rollback alla versione precedente
    \end{itemize}
\end{enumerate}

\subsubsection{Applicazione principale}
L'applicazione principale si trova nel file \texttt{main/main.c} e utilizza le funzioni
definite nei file \texttt{wifi.c} e \texttt{ota.c} per connettere il dispositivo
alla rete Wi-Fi e scaricare il nuovo firmware. I passi eseguiti sono i seguenti:
\begin{enumerate}
  \item Controlla il nuovo firmware tramite la funzione \texttt{diagnose\_new\_firmware()}
  \item Si connette alla rete Wi-Fi tramite la funzione \texttt{connect\_wifi()}
  \item Crea una task per gestire l'aggiornamento OTA chiamando la funzione
    \texttt{download\_new\_firmware()}
  \item Crea una task per eseguire l'applicazione principale (in questo caso un semplice
    loop che stampa un messaggio ogni 5 secondi)
\end{enumerate}

% \section{Analisi dei risultati}
% \section{Conclusioni}

\nocite{*}
\printbibliography[
heading=bibintoc,
title={Bibliografia}
]
\end{document}
