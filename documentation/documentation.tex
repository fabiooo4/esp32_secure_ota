\documentclass[a4paper]{article}

\usepackage[italian]{babel}
\usepackage{float}
\usepackage{makecell}

\usepackage{hyperref}
\hypersetup{
  colorlinks=false,
}

% Code blocks
\usepackage{listings}
\usepackage{xcolor}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.95}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,
	breaklines=true,
	captionpos=b,
	keepspaces=true,
	numbers=left,
	numbersep=5pt,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2
}

\lstset{style=mystyle}

\begin{document}

\input{title.tex}

\tableofcontents
\pagebreak

\section{Introduzione}
Questo progetto consiste nell'implementazione di un sistema che permetta di aggiornare
il firmware dell'ESP32 da remoto (Over The Air) tramite Wi-Fi. L'obiettivo principale è
quello di attivare le funzionalità di sicurezza del microcontrollore in modo da proteggere
il dispositivo da accessi non autorizzati. Le funzionalità di sicurezza includono:
\begin{itemize}
  \item \textbf{Secure OTA}: Garantisce che il nuovo firmware sia autentico e non
    compromesso
  \item \textbf{Secure Boot}: Impedisce l'esecuzione di firmware non autorizzato
  \item \textbf{Flash Encryption}: Protegge i dati memorizzati nella memoria flash
    del dispositivo
\end{itemize}


\section{Cenni teorici}

\subsection{Aggiornamenti OTA (Over The Air)}
Gli aggiornamenti OTA permettono di aggiornare il firmware del dispositivo durante la
sua normale esecuzione, senza la necessità di collegarlo fisicamente a un computer. Le
modalità di aggiornamento si distinguono in base alla vulnerabilità del sistema:
\begin{itemize}
  \item \textbf{Modalità sicura}: L'aggiornamento di alcune partizioni è resiliente,
    cioè garantisce l'operabilità del dispositivo anche in caso di perdita di alimentazione
    o di errore durante l'aggiornamento. Solo il seguente tipo di partizione supporta
    la modalità sicura:
    \begin{itemize}
      \item \textbf{Application}: OTA configura la partition table in modo da avere
        due partizioni per l'aggiornamento (\texttt{ota\_0} e \texttt{ota\_1}) e una
        partizione per lo stato di boot (\texttt{ota\_data}). Durante l'aggiornamento il
        nuovo firmware viene scritto nella partizione OTA attualmente non selezionata
        per il boot. Una volta completato l'aggiornamento, la partizione \texttt{ota\_data}
        viene aggiornata per indicare che la partizione OTA appena scritta deve essere
        utilizzata al boot successivo. Se la partizione \texttt{ota\_data} non contiene
        alcun dato il dispositivo esegue il boot dalla partizione \texttt{factory}.

        La partition table con due partizioni OTA è la seguente:
        \begin{lstlisting}
# ESP-IDF Partition Table
# Name,   Type, SubType, Offset,  Size, Flags
nvs,      data, nvs,     0x9000,  0x4000,
otadata,  data, ota,     0xd000,  0x2000,
phy_init, data, phy,     0xf000,  0x1000,
factory,  app,  factory, 0x10000,  1M,
ota_0,    app,  ota_0,   0x110000, 1M,
ota_1,    app,  ota_1,   0x210000, 1M,
        \end{lstlisting}
    \end{itemize}
  \item \textbf{Modalità non sicura}: L'aggiornamento di alcune partizioni è vulnerabile,
    cioè in caso di perdita di alimentazione o di errore durante l'aggiornamento il
    dispositivo potrebbe non essere più operabile. Una partizione temporanea riceve
    i dati della nuova immagine e, una volta completato il trasferimento, l'immagine viene
    copiata nella partizione di destinazione. Se l'operazione di copia viene interrotta
    potrebbero verificarsi problemi di boot. Le partizioni che supportano la modalità non
    sicura sono:
    \begin{itemize}
      \item \textbf{Bootloader}
      \item \textbf{Partition Table}
      \item \textbf{Partizioni data} (ad esempio NVS, FAT, ecc...)
    \end{itemize}
\end{itemize}

\subsubsection{Partizione OTA Data}
Al primo avvio del dispositivo la partizione \texttt{ota\_data} deve essere vuota (tutti i
byte a 0xFF) in modo da far eseguire il boot dal'applicazione nella partizione
\texttt{factory}. Se l'applicazione in \texttt{factory} non è presente viene eseguito il boot
della prima partizione OTA disponibile (di solito \texttt{ota\_0}).

Dopo il primo aggiornamento OTA, la partizione \texttt{ota\_data} viene aggiornata per
indicare quale partizione OTA deve essere utilizzata al successivo boot. La dimensione
di \texttt{ota\_data} è di due settori (0x2000 bytes = 8192 bytes) in modo da evitare
errori mentre si scrive la partizione. I due settori sono cancellati indipendentemente
e scritti con gli stessi dati. In questo modo se i dati dei due settori non coincidono
viene usato un counter per determinare quale settore è stato scritto più recentemente.

\subsubsection{App rollback}
L'obiettivo dell'app rollback è quello di tenere il funzionante il dispositivo dopo un
aggiornamento e permette di tornare alla versione precedente del firmware se la nuova
versione non funziona correttamente (solo le partizioni OTA possono effettuare il rollback).
Dopo un aggiornamento OTA con rollback attivo si hanno le seguenti possibilità:
\begin{itemize}
  \item Se l'app funziona bene \texttt{esp\_ota\_mark\_app\_valid\_cancel\_rollback()}
    imposta lo stato dell'applicazione a \texttt{ESP\_OTA\_IMG\_VALID}.

  \item Se l'app non funziona correttamente il dispositivo esegue il rollback alla versione
    precedente e \texttt{esp\_ota\_mark\_app\_invalid\_rollback()} imposta lo stato
    dell'applicazione a \texttt{ESP\_OTA\_IMG\_INVALID}.

  \item Se l'impostazione \texttt{CONFIG\_BOOTLOADER\_APP\_ROLLBACK\_ENABLE} è abilitata
    e viene effettuato un reset, allora viene effettuato un rollback senza chiamare
    nessuna funzione nell'applicazione. Questa opzione permette di intercettare la
    prima esecuzione di una nuova applicazione per confermare che funzioni correttamente.
\end{itemize}

\vspace{1em}
\noindent
Gli stati che controllano il processo di selezione dell'applicazione sono:
\begin{table}[H]
  \centering
  \begin{tabular}{|l|l|}
    \hline
    \textbf{Stato} & \textbf{Restrizioni sulla nuova app} \\
    \hline
    \texttt{ESP\_OTA\_IMG\_VALID} & Nessuna restrizione. Verrà selezionata \\
    \hline
    \texttt{ESP\_OTA\_IMG\_UNDEFINED} & Nessuna restrizione. Verrà selezionata \\
    \hline
    \texttt{ESP\_OTA\_IMG\_INVALID} & Non verrà selezionata \\
    \hline
    \texttt{ESP\_OTA\_IMG\_ABORTED} & Non verrà selezionata \\
    \hline
    \texttt{ESP\_OTA\_IMG\_NEW} & \makecell[l]{Se l'opzione \\
    \texttt{CONFIG\_BOOTLOADER\_APP\_ROLLBACK\_ENABLE} \\
    è abilitata, l'app verrà selezionata solo una \\
    volta. Nel bootloader lo stato viene subito \\
    impostato a \texttt{ESP\_OTA\_IMG\_PENDING\_VERIFY}.} \\
    \hline
      \texttt{ESP\_OTA\_IMG\_PENDING\_VERIFY} & \makecell[l]{Se l'opzione \\
    \texttt{CONFIG\_BOOTLOADER\_APP\_ROLLBACK\_ENABLE} \\
    è abilitata, l'app non verrà selezionata. \\
    Nel bootloader lo stato viene \\
    impostato a \\
    \texttt{ESP\_OTA\_IMG\_ABORTED}.} \\
    \hline
  \end{tabular}
\end{table}
\noindent
L'impostazione di questi stati avviene nei seguenti casi:
\begin{itemize}
  \item \texttt{ESP\_OTA\_IMG\_VALID}: impostato dalla funzione \\
    \texttt{esp\_ota\_mark\_app\_valid\_cancel\_rollback()}.

  \item \texttt{ESP\_OTA\_IMG\_UNDEFINED}: impostato dalla funzione \\
    \texttt{esp\_ota\_set\_boot\_partition()} se l'impostazione \\
    \texttt{CONFIG\_BOOTLOADER\_APP\_ROLLBACK\_ENABLE} è disabilitata.

  \item \texttt{ESP\_OTA\_IMG\_NEW}: impostato dalla funzione \\
    \texttt{esp\_ota\_set\_boot\_partition()} se l'impostazione \\
    \texttt{CONFIG\_BOOTLOADER\_APP\_ROLLBACK\_ENABLE} è abilitata.

  \item \texttt{ESP\_OTA\_IMG\_INVALID}: impostato dalla funzione \\
    \texttt{esp\_ota\_mark\_app\_invalid\_rollback()} o \\
    \texttt{esp\_ota\_mark\_app\_invalid\_rollback\_and\_reboot()}.

  \item \texttt{ESP\_OTA\_IMG\_ABORTED}: impostato se l'operabilità dell'applicazione non
    è stata confermata e avviene un reboot quando l'impostazione \\
    \texttt{CONFIG\_BOOTLOADER\_APP\_ROLLBACK\_ENABLE} è abilitata.

  \item \texttt{ESP\_OTA\_IMG\_PENDING\_VERIFY}: impostato nel bootloader se l'impostazione \\
    \texttt{CONFIG\_BOOTLOADER\_APP\_ROLLBACK\_ENABLE} è abilitata e l'applicazione
    selezionata è nello stato \texttt{ESP\_OTA\_IMG\_NEW}.
\end{itemize}


\section{Implementazione}

\subsection{Aggiornamenti OTA}
\subsubsection{Configurazione del progetto}
Per abilitare gli aggiornamenti OTA è stato necessario configurare il progetto ESP-IDF
con le seguenti componenti:
\begin{itemize}
  \item \textbf{Partition table e memoria flash}: è stato creato il file\\
    \texttt{sdkconfig.defaults}
    che contiene la configurazione di default del progetto. All'interno è stato
    definito l'utilizzo della partition table con due partizioni OTA:
\begin{lstlisting}
CONFIG_PARTITION_TABLE_TWO_OTA=y
\end{lstlisting}
    e sono state impostate le dimensioni della memoria flash a 4MB:
\begin{lstlisting}
CONFIG_ESPTOOLPY_FLASHSIZE_4MB=y
\end{lstlisting}

  \item \textbf{Server HTTP}: per permettere il download del nuovo firmware è stato
    creato un server HTTP in \texttt{server/pytest\_simple\_ota.py} che rende
    disponibile il file binario del firmware aggiornato.

    Il server richiede, nella sua cartella, la presenza di un certificato SSL per
    permettere connessioni sicure attraverso HTTPS. Il certificato è stato generato
    eseguendo il seguente comando nella cartella \texttt{server/}:
\begin{lstlisting}
cd server
openssl req -x509 -newkey rsa:2048 -keyout ca_key.pem -out ca_cert.pem -days 365 -nodes
\end{lstlisting}
    \textbf{Nota}: durante la creazione del certificato nel campo \texttt{Common Name (CN)}
    deve essere inserito il nome host del server. Se il server viene eseguito in locale
    il campo deve essere impostato con l'indirizzo IP del server.

    Una volta generato il certificato bisogna flashare il file \texttt{ca\_cert.pem}
    sul dispositivo in modo che possa verificare l'autenticità del server.
    Per fare ciò bisogna copiare il file nella cartella \texttt{server\_certs/} del
    progetto:
\begin{lstlisting}
cp ca_cert.pem ../server_certs
\end{lstlisting}
    Inoltre è necessario modificare il file \texttt{main/CMakeLists.txt} per includere
    il certificato nel firmware:
\begin{lstlisting}
idf_build_get_property(project_dir PROJECT_DIR)
idf_component_register(SRCS "main.c" INCLUDE_DIRS "."
    EMBED_TXTFILES ${project_dir}/server_certs/ca_cert.pem)
\end{lstlisting}

    Una volta configurato il tutto, il server può essere avviato eseguendo il comando:
\begin{lstlisting}
python pytest_simple_ota.py <BIN_DIR> <PORT> [CERT_DIR]
\end{lstlisting}
    Dove:
    \begin{itemize}
      \item \texttt{<BIN\_DIR>} è la cartella che contiene il file binario del firmware.
      \item \texttt{<PORT>} è la  porta su cui eseguire il server HTTP.
      \item \texttt{[CERT\_DIR]} (opzionale) è cartella che contiene il certificato SSL
        del server. Se non viene specificata viene usata la cartella corrente.
    \end{itemize}
    Se tutto è andato a buon fine l'output del server sarà simile al seguente:
\begin{lstlisting}
$ python pytest_simple_ota.py build 8070
Starting HTTPS server at "https://:8070"
192.168.10.106 - - [01/Jan/2026 12:00:00] "GET /esp32_secure_ota.bin HTTP/1.1" 200 -
\end{lstlisting}

  \item \textbf{Supporto del versionamento}: per tenere traccia delle versioni del firmware
    è stato aggiunto il file \texttt{version.txt} nella cartella principale del progetto
    che contiene il numero di versione corrente. Questo numero viene inserito nel
    file binario del firmware durante la compilazione e può essere letto dall'applicazione
    per confrontare la versione corrente con quella disponibile sul server ed evitare
    aggiornamenti non necessari.

  \item \textbf{Accesso Wi-Fi}: per connettere il dispositivo alla rete Wi-Fi è stata
    implementata la logica di connessione nel file \texttt{main/wifi.c}.

  \item \textbf{Configurazione Wi-Fi e server HTTP}: per fornire le credenziali di
    accesso alla rete Wi-Fi e l'indirizzo del server HTTP è stata creata una sezione
    nel menu di configurazione del progetto (menuconfig), nel file
    \texttt{main/Kconfig.projbuild}. Per accedere al menuconfig bisogna eseguire
    il comando:
\begin{lstlisting}
idf.py menuconfig
\end{lstlisting}
    e navigare fino alla sezione \texttt{Over The Air Updates configuration} dove è
    possibile impostare:
    \begin{itemize}
      \item \textbf{Wifi configuration}
        \begin{itemize}
          \item \texttt{SSID}: nome della rete Wi-Fi
          \item \texttt{Password}: password della rete Wi-Fi
          \item \texttt{Maximum retries}: numero massimo di tentativi di riconnessione
          \item \texttt{WPA3 SAE mode selection}: modalità di autenticazione WPA3
          \item \texttt{Password identifier}: identificatore della password WPA3
          \item \texttt{WiFi Scan auth mode threshold}: modalità di
            autenticazione minima accettata durante la scansione delle reti
        \end{itemize}

      \item \textbf{Upgrade server}
        \begin{itemize}
          \item \texttt{Firmware upgrade URL}: URL del server HTTP che ospita il file
            binario del firmware. Deve essere nel formato:
\begin{lstlisting}
https://<host-ip-address>:<host-port>/<firmware-image-filename>
\end{lstlisting}
            dove:
            \begin{itemize}
              \item \texttt{<host-ip-address>}: hostname o indirizzo IP del server\\ HTTP.
              \item \texttt{<host-port>}: porta su cui è in esecuzione il server HTTP.
              \item \texttt{<firmware-image-filename>}: nome del file binario del\\ firmware.
                \textbf{Deve coincidere con il nome del file messo a disposizione dal server}.
            \end{itemize}

          \item \texttt{Skip server certificate CN field check}: se abilitato, il
            dispositivo non verificherà il campo \texttt{Common Name (CN)} del
            certificato SSL. Utile per testare il server in locale senza dover generare
            un certificato con l'indirizzo IP come CN.

          \item \texttt{Skip firmware version check}: se abilitato, il dispositivo non
            confronterà la versione del firmware corrente con quella disponibile sul
            server prima di effettuare l'aggiornamento OTA.

          \item \texttt{OTA recieve timeout}: tempo massimo (in millisecondi)
            per ricevere una risposta dal server HTTP durante l'aggiornamento OTA.
        \end{itemize}

    \end{itemize}
\end{itemize}

\subsubsection{Connessione Wi-Fi}
La connessione alla rete Wi-Fi viene gestita nel file \texttt{main/wifi.c} che
fornisce la funzione \texttt{connect\_wifi()}. Questa funzione gestisce la connessione
alla rete Wi-Fi utilizzando le credenziali fornite nel menuconfig e la riconnessione
in caso di disconnessione. La funzione esegue i seguenti passaggi:
\begin{enumerate}
  \item Inizializza il driver Wi-Fi
  \item Chiama un handler per gestire gli eventi di connessione e disconnessione 
    dalla rete Wi-Fi
  \item Chiama un handler per gestire l'acquisizione dell'indirizzo IP
  \item Imposta il device in modalità stazione Wi-Fi con la configurazione fornita
    dal menuconfig
  \item Avvia la connessione alla rete Wi-Fi
  \item Attende fino a quando il dispositivo non si connette alla rete o raggiunge
    il numero massimo di tentativi di riconnessione
  \item Restituisce lo stato della connessione (successo o fallimento)
\end{enumerate}

\subsubsection{Aggiornamento OTA}
L'aggiornamento OTA viene gestito nel file \texttt{main/ota.c} che fornisce le funzione
\texttt{download\_new\_firmware()} e \texttt{diagnose\_new\_firmware()}. La funzione
\texttt{download\_new\_firmware()} connette il dispositivo al server HTTP e scarica
il nuovo firmware, se disponibile, e lo imposta come nuova applicazione di boot.
I passi eseguiti sono i seguenti:
\begin{enumerate}
  \item Recupera le partizioni di boot e OTA correnti
  \item Si connette al server HTTP utilizzando l'URL fornito nel menuconfig
  \item Recupera la partizione OTA non attualmente in uso per il boot
  \item Legge il file binario del firmware dal server HTTP
  \item Confronta la versione del firmware corrente con quella scaricata
    \begin{itemize}
      \item Se l'aggiornamento non è necessario viene eseguito un loop infinito
        che attende un reset del dispositivo per ritentare l'aggiornamento
    \end{itemize}
  \item Inizializza l'aggiornamento OTA
  \item Scrive i dati del firmware scaricato nella partizione OTA non in uso
  \item Controlla che tutti i dati siano stati scritti correttamente
  \item Disattiva l'aggiornamento OTA
  \item Imposta la partizione OTA appena scritta come partizione di boot
  \item Riavvia il dispositivo per eseguire il nuovo firmware
\end{enumerate}

\noindent
La funzione \texttt{diagnose\_new\_firmware()} permette di verificare se il nuovo
firmware funziona correttamente e, in caso negativo, effettua il rollback alla versione
precedente. I passi eseguiti sono i seguenti:
\begin{enumerate}
  \item Controlla se l'applicazione corrente è al primo avvio dopo un aggiornamento OTA
  \item Esegue la funzione di diagnosi del firmware (in questo caso un semplice delay di
    5 secondi che simula un controllo)
    \begin{itemize}
      \item Se la diagnosi ha esito positivo, conferma che il nuovo firmware è valido
        e cancella il rollback
      \item Se la diagnosi ha esito negativo, marca il firmware come non valido
        ed esegue il rollback alla versione precedente
    \end{itemize}
\end{enumerate}

\subsubsection{Applicazione principale}
L'applicazione principale si trova nel file \texttt{main/main.c} e utilizza le funzioni
definite nei file \texttt{wifi.c} e \texttt{ota.c} per connettere il dispositivo
alla rete Wi-Fi e scaricare il nuovo firmware. I passi eseguiti sono i seguenti:
\begin{enumerate}
  \item Controlla il nuovo firmware tramite la funzione \texttt{diagnose\_new\_firmware()}
  \item Si connette alla rete Wi-Fi tramite la funzione \texttt{connect\_wifi()}
  \item Crea una task per gestire l'aggiornamento OTA chiamando la funzione
    \texttt{download\_new\_firmware()}
  \item Crea una task per eseguire l'applicazione principale (in questo caso un semplice
    loop che stampa un messaggio ogni 5 secondi)
\end{enumerate}

% \section{Analisi dei risultati}
% \section{Conclusioni}

\end{document}
